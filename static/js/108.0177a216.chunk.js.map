{"version":3,"sources":["../node_modules/@codemirror/stream-parser/dist/index.js"],"names":["countCol","string","end","tabSize","startIndex","startValue","search","length","n","i","charCodeAt","StringStream","indentUnit","this","pos","start","lastColumnPos","lastColumnValue","charAt","undefined","match","ch","RegExp","test","eat","found","indexOf","pattern","consume","caseInsensitive","cased","str","toLowerCase","substr","slice","index","defaultCopyState","state","newState","prop","val","Array","StreamLanguage","parser","self","spec","data","defineLanguageFacet","languageData","p","token","blankLine","startState","copyState","indent","impl","input","fragments","ranges","Parse","Parser","type","NodeType","define","id","typeArray","name","props","languageDataProp","add","push","docID","indentService","of","cx","getIndent","streamParser","stateAfter","NodeProp","perNode","tree","syntaxTree","at","resolve","topNode","parent","statePos","findState","from","unit","line","doc","lineAt","Math","min","to","stream","text","readToken","exec","Language","lang","off","startPos","before","children","child","positions","Tree","cutTree","inside","inner","concat","stoppedAt","chunks","chunkPos","chunk","chunkReused","rangeIndex","context","ParseContext","get","editorState","f","openStart","openEnd","offset","getIndentUnit","empty","findStartInFragments","parsedPos","chunkStart","viewport","skipUntilInView","parseEnd","parseLine","finishChunk","finish","lineChunks","eol","lineAfter","rangeEnd","rangeStart","after","side","offPos","size","skipGapsTo","len0","nextLine","emitToken","tokenID","build","buffer","nodeSet","topID","maxBufferLength","reused","balance","result","Error","tokenTable","Object","create","none","NodeSet","warned","tag","tagStr","split","part","value","tags","warnForPart","replace","styleTags","createTokenType","legacyName","msg","console","warn"],"mappings":"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","file":"static/js/108.0177a216.chunk.js","sourcesContent":["import { Parser, NodeProp, Tree, NodeType, NodeSet } from '@lezer/common';\nimport { tags, styleTags } from '@codemirror/highlight';\nimport { Language, defineLanguageFacet, indentService, syntaxTree, ParseContext, getIndentUnit, languageDataProp } from '@codemirror/language';\n\n// Counts the column offset in a string, taking tabs into account.\n// Used mostly to find indentation.\nfunction countCol(string, end, tabSize, startIndex = 0, startValue = 0) {\n    if (end == null) {\n        end = string.search(/[^\\s\\u00a0]/);\n        if (end == -1)\n            end = string.length;\n    }\n    let n = startValue;\n    for (let i = startIndex; i < end; i++) {\n        if (string.charCodeAt(i) == 9)\n            n += tabSize - (n % tabSize);\n        else\n            n++;\n    }\n    return n;\n}\n/**\nEncapsulates a single line of input. Given to stream syntax code,\nwhich uses it to tokenize the content.\n*/\nclass StringStream {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The line.\n    */\n    string, tabSize, \n    /**\n    The current indent unit size.\n    */\n    indentUnit) {\n        this.string = string;\n        this.tabSize = tabSize;\n        this.indentUnit = indentUnit;\n        /**\n        The current position on the line.\n        */\n        this.pos = 0;\n        /**\n        The start position of the current token.\n        */\n        this.start = 0;\n        this.lastColumnPos = 0;\n        this.lastColumnValue = 0;\n    }\n    /**\n    True if we are at the end of the line.\n    */\n    eol() { return this.pos >= this.string.length; }\n    /**\n    True if we are at the start of the line.\n    */\n    sol() { return this.pos == 0; }\n    /**\n    Get the next code unit after the current position, or undefined\n    if we're at the end of the line.\n    */\n    peek() { return this.string.charAt(this.pos) || undefined; }\n    /**\n    Read the next code unit and advance `this.pos`.\n    */\n    next() {\n        if (this.pos < this.string.length)\n            return this.string.charAt(this.pos++);\n    }\n    /**\n    Match the next character against the given string, regular\n    expression, or predicate. Consume and return it if it matches.\n    */\n    eat(match) {\n        let ch = this.string.charAt(this.pos);\n        let ok;\n        if (typeof match == \"string\")\n            ok = ch == match;\n        else\n            ok = ch && (match instanceof RegExp ? match.test(ch) : match(ch));\n        if (ok) {\n            ++this.pos;\n            return ch;\n        }\n    }\n    /**\n    Continue matching characters that match the given string,\n    regular expression, or predicate function. Return true if any\n    characters were consumed.\n    */\n    eatWhile(match) {\n        let start = this.pos;\n        while (this.eat(match)) { }\n        return this.pos > start;\n    }\n    /**\n    Consume whitespace ahead of `this.pos`. Return true if any was\n    found.\n    */\n    eatSpace() {\n        let start = this.pos;\n        while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos)))\n            ++this.pos;\n        return this.pos > start;\n    }\n    /**\n    Move to the end of the line.\n    */\n    skipToEnd() { this.pos = this.string.length; }\n    /**\n    Move to directly before the given character, if found on the\n    current line.\n    */\n    skipTo(ch) {\n        let found = this.string.indexOf(ch, this.pos);\n        if (found > -1) {\n            this.pos = found;\n            return true;\n        }\n    }\n    /**\n    Move back `n` characters.\n    */\n    backUp(n) { this.pos -= n; }\n    /**\n    Get the column position at `this.pos`.\n    */\n    column() {\n        if (this.lastColumnPos < this.start) {\n            this.lastColumnValue = countCol(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n            this.lastColumnPos = this.start;\n        }\n        return this.lastColumnValue;\n    }\n    /**\n    Get the indentation column of the current line.\n    */\n    indentation() {\n        return countCol(this.string, null, this.tabSize);\n    }\n    /**\n    Match the input against the given string or regular expression\n    (which should start with a `^`). Return true or the regexp match\n    if it matches.\n    \n    Unless `consume` is set to `false`, this will move `this.pos`\n    past the matched text.\n    \n    When matching a string `caseInsensitive` can be set to true to\n    make the match case-insensitive.\n    */\n    match(pattern, consume, caseInsensitive) {\n        if (typeof pattern == \"string\") {\n            let cased = (str) => caseInsensitive ? str.toLowerCase() : str;\n            let substr = this.string.substr(this.pos, pattern.length);\n            if (cased(substr) == cased(pattern)) {\n                if (consume !== false)\n                    this.pos += pattern.length;\n                return true;\n            }\n            else\n                return null;\n        }\n        else {\n            let match = this.string.slice(this.pos).match(pattern);\n            if (match && match.index > 0)\n                return null;\n            if (match && consume !== false)\n                this.pos += match[0].length;\n            return match;\n        }\n    }\n    /**\n    Get the current token.\n    */\n    current() { return this.string.slice(this.start, this.pos); }\n}\n\nfunction fullParser(spec) {\n    return {\n        token: spec.token,\n        blankLine: spec.blankLine || (() => { }),\n        startState: spec.startState || (() => true),\n        copyState: spec.copyState || defaultCopyState,\n        indent: spec.indent || (() => null),\n        languageData: spec.languageData || {}\n    };\n}\nfunction defaultCopyState(state) {\n    if (typeof state != \"object\")\n        return state;\n    let newState = {};\n    for (let prop in state) {\n        let val = state[prop];\n        newState[prop] = (val instanceof Array ? val.slice() : val);\n    }\n    return newState;\n}\n/**\nA [language](https://codemirror.net/6/docs/ref/#language.Language) class based on a streaming\nparser.\n*/\nclass StreamLanguage extends Language {\n    constructor(parser) {\n        let data = defineLanguageFacet(parser.languageData);\n        let p = fullParser(parser), self;\n        let impl = new class extends Parser {\n            createParse(input, fragments, ranges) {\n                return new Parse(self, input, fragments, ranges);\n            }\n        };\n        super(data, impl, docID(data), [indentService.of((cx, pos) => this.getIndent(cx, pos))]);\n        self = this;\n        this.streamParser = p;\n        this.stateAfter = new NodeProp({ perNode: true });\n    }\n    static define(spec) { return new StreamLanguage(spec); }\n    getIndent(cx, pos) {\n        let tree = syntaxTree(cx.state), at = tree.resolve(pos);\n        while (at && at.type != this.topNode)\n            at = at.parent;\n        if (!at)\n            return null;\n        let start = findState(this, tree, 0, at.from, pos), statePos, state;\n        if (start) {\n            state = start.state;\n            statePos = start.pos + 1;\n        }\n        else {\n            state = this.streamParser.startState(cx.unit);\n            statePos = 0;\n        }\n        if (pos - statePos > 10000 /* MaxIndentScanDist */)\n            return null;\n        while (statePos < pos) {\n            let line = cx.state.doc.lineAt(statePos), end = Math.min(pos, line.to);\n            if (line.length) {\n                let stream = new StringStream(line.text, cx.state.tabSize, cx.unit);\n                while (stream.pos < end - line.from)\n                    readToken(this.streamParser.token, stream, state);\n            }\n            else {\n                this.streamParser.blankLine(state, cx.unit);\n            }\n            if (end == pos)\n                break;\n            statePos = line.to + 1;\n        }\n        let { text } = cx.state.doc.lineAt(pos);\n        return this.streamParser.indent(state, /^\\s*(.*)/.exec(text)[1], cx);\n    }\n    get allowsNesting() { return false; }\n}\nfunction findState(lang, tree, off, startPos, before) {\n    let state = off >= startPos && off + tree.length <= before && tree.prop(lang.stateAfter);\n    if (state)\n        return { state: lang.streamParser.copyState(state), pos: off + tree.length };\n    for (let i = tree.children.length - 1; i >= 0; i--) {\n        let child = tree.children[i], pos = off + tree.positions[i];\n        let found = child instanceof Tree && pos < before && findState(lang, child, pos, startPos, before);\n        if (found)\n            return found;\n    }\n    return null;\n}\nfunction cutTree(lang, tree, from, to, inside) {\n    if (inside && from <= 0 && to >= tree.length)\n        return tree;\n    if (!inside && tree.type == lang.topNode)\n        inside = true;\n    for (let i = tree.children.length - 1; i >= 0; i--) {\n        let pos = tree.positions[i] + from, child = tree.children[i], inner;\n        if (pos < to && child instanceof Tree) {\n            if (!(inner = cutTree(lang, child, from - pos, to - pos, inside)))\n                break;\n            return !inside ? inner\n                : new Tree(tree.type, tree.children.slice(0, i).concat(inner), tree.positions.slice(0, i + 1), pos + inner.length);\n        }\n    }\n    return null;\n}\nfunction findStartInFragments(lang, fragments, startPos, editorState) {\n    for (let f of fragments) {\n        let from = f.from + (f.openStart ? 25 : 0), to = f.to - (f.openEnd ? 25 : 0);\n        let found = from <= startPos && to > startPos && findState(lang, f.tree, 0 - f.offset, startPos, to), tree;\n        if (found && (tree = cutTree(lang, f.tree, startPos + f.offset, found.pos + f.offset, false)))\n            return { state: found.state, tree };\n    }\n    return { state: lang.streamParser.startState(editorState ? getIndentUnit(editorState) : 4), tree: Tree.empty };\n}\nclass Parse {\n    constructor(lang, input, fragments, ranges) {\n        this.lang = lang;\n        this.input = input;\n        this.fragments = fragments;\n        this.ranges = ranges;\n        this.stoppedAt = null;\n        this.chunks = [];\n        this.chunkPos = [];\n        this.chunk = [];\n        this.chunkReused = undefined;\n        this.rangeIndex = 0;\n        this.to = ranges[ranges.length - 1].to;\n        let context = ParseContext.get(), from = ranges[0].from;\n        let { state, tree } = findStartInFragments(lang, fragments, from, context === null || context === void 0 ? void 0 : context.state);\n        this.state = state;\n        this.parsedPos = this.chunkStart = from + tree.length;\n        if (tree.length) {\n            this.chunks.push(tree);\n            this.chunkPos.push(0);\n        }\n        if (context && this.parsedPos < context.viewport.from - 100000 /* MaxDistanceBeforeViewport */) {\n            this.state = this.lang.streamParser.startState(getIndentUnit(context.state));\n            context.skipUntilInView(this.parsedPos, context.viewport.from);\n            this.parsedPos = context.viewport.from;\n        }\n    }\n    advance() {\n        let context = ParseContext.get();\n        let parseEnd = this.stoppedAt == null ? this.to : this.stoppedAt;\n        let end = Math.min(parseEnd, this.chunkStart + 2048 /* ChunkSize */);\n        if (context)\n            end = Math.min(end, context.viewport.to);\n        while (this.parsedPos < end)\n            this.parseLine(context);\n        if (this.chunkStart < this.parsedPos)\n            this.finishChunk();\n        if (this.parsedPos >= parseEnd)\n            return this.finish();\n        if (context && this.parsedPos > context.viewport.to) {\n            context.skipUntilInView(this.parsedPos, parseEnd);\n            return this.finish();\n        }\n        return null;\n    }\n    stopAt(pos) {\n        this.stoppedAt = pos;\n    }\n    lineAfter(pos) {\n        let chunk = this.input.chunk(pos);\n        if (!this.input.lineChunks) {\n            let eol = chunk.indexOf(\"\\n\");\n            if (eol > -1)\n                chunk = chunk.slice(0, eol);\n        }\n        else if (chunk == \"\\n\") {\n            chunk = \"\";\n        }\n        return pos + chunk.length <= this.to ? chunk : chunk.slice(0, this.to - pos);\n    }\n    nextLine() {\n        let from = this.parsedPos, line = this.lineAfter(from), end = from + line.length;\n        for (let index = this.rangeIndex;;) {\n            let rangeEnd = this.ranges[index].to;\n            if (rangeEnd >= end)\n                break;\n            line = line.slice(0, rangeEnd - (end - line.length));\n            index++;\n            if (index == this.ranges.length)\n                break;\n            let rangeStart = this.ranges[index].from;\n            let after = this.lineAfter(rangeStart);\n            line += after;\n            end = rangeStart + after.length;\n        }\n        return { line, end };\n    }\n    skipGapsTo(pos, offset, side) {\n        for (;;) {\n            let end = this.ranges[this.rangeIndex].to, offPos = pos + offset;\n            if (side > 0 ? end > offPos : end >= offPos)\n                break;\n            let start = this.ranges[++this.rangeIndex].from;\n            offset += start - end;\n        }\n        return offset;\n    }\n    emitToken(id, from, to, size, offset) {\n        if (this.ranges.length > 1) {\n            offset = this.skipGapsTo(from, offset, 1);\n            from += offset;\n            let len0 = this.chunk.length;\n            offset = this.skipGapsTo(to, offset, -1);\n            to += offset;\n            size += this.chunk.length - len0;\n        }\n        this.chunk.push(id, from, to, size);\n        return offset;\n    }\n    parseLine(context) {\n        let { line, end } = this.nextLine(), offset = 0, { streamParser } = this.lang;\n        let stream = new StringStream(line, context ? context.state.tabSize : 4, context ? getIndentUnit(context.state) : 2);\n        if (stream.eol()) {\n            streamParser.blankLine(this.state, stream.indentUnit);\n        }\n        else {\n            while (!stream.eol()) {\n                let token = readToken(streamParser.token, stream, this.state);\n                if (token)\n                    offset = this.emitToken(tokenID(token), this.parsedPos + stream.start, this.parsedPos + stream.pos, 4, offset);\n            }\n        }\n        this.parsedPos = end;\n        if (this.parsedPos < this.to)\n            this.parsedPos++;\n    }\n    finishChunk() {\n        let tree = Tree.build({\n            buffer: this.chunk,\n            start: this.chunkStart,\n            length: this.parsedPos - this.chunkStart,\n            nodeSet,\n            topID: 0,\n            maxBufferLength: 2048 /* ChunkSize */,\n            reused: this.chunkReused\n        });\n        tree = new Tree(tree.type, tree.children, tree.positions, tree.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]);\n        this.chunks.push(tree);\n        this.chunkPos.push(this.chunkStart - this.ranges[0].from);\n        this.chunk = [];\n        this.chunkReused = undefined;\n        this.chunkStart = this.parsedPos;\n    }\n    finish() {\n        return new Tree(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();\n    }\n}\nfunction readToken(token, stream, state) {\n    stream.start = stream.pos;\n    for (let i = 0; i < 10; i++) {\n        let result = token(stream, state);\n        if (stream.pos > stream.start)\n            return result;\n    }\n    throw new Error(\"Stream parser failed to advance stream.\");\n}\nconst tokenTable = /*@__PURE__*/Object.create(null);\nconst typeArray = [NodeType.none];\nconst nodeSet = /*@__PURE__*/new NodeSet(typeArray);\nconst warned = [];\nfunction tokenID(tag) {\n    return !tag ? 0 : tokenTable[tag] || (tokenTable[tag] = createTokenType(tag));\n}\nfor (let [legacyName, name] of [\n    [\"variable\", \"variableName\"],\n    [\"variable-2\", \"variableName.special\"],\n    [\"string-2\", \"string.special\"],\n    [\"def\", \"variableName.definition\"],\n    [\"tag\", \"typeName\"],\n    [\"attribute\", \"propertyName\"],\n    [\"type\", \"typeName\"],\n    [\"builtin\", \"variableName.standard\"],\n    [\"qualifier\", \"modifier\"],\n    [\"error\", \"invalid\"],\n    [\"header\", \"heading\"],\n    [\"property\", \"propertyName\"]\n])\n    tokenTable[legacyName] = /*@__PURE__*/tokenID(name);\nfunction warnForPart(part, msg) {\n    if (warned.indexOf(part) > -1)\n        return;\n    warned.push(part);\n    console.warn(msg);\n}\nfunction createTokenType(tagStr) {\n    let tag = null;\n    for (let part of tagStr.split(\".\")) {\n        let value = tags[part];\n        if (!value) {\n            warnForPart(part, `Unknown highlighting tag ${part}`);\n        }\n        else if (typeof value == \"function\") {\n            if (!tag)\n                warnForPart(part, `Modifier ${part} used at start of tag`);\n            else\n                tag = value(tag);\n        }\n        else {\n            if (tag)\n                warnForPart(part, `Tag ${part} used as modifier`);\n            else\n                tag = value;\n        }\n    }\n    if (!tag)\n        return 0;\n    let name = tagStr.replace(/ /g, \"_\"), type = NodeType.define({\n        id: typeArray.length,\n        name,\n        props: [styleTags({ [name]: tag })]\n    });\n    typeArray.push(type);\n    return type.id;\n}\nfunction docID(data) {\n    let type = NodeType.define({ id: typeArray.length, name: \"Document\", props: [languageDataProp.add(() => data)] });\n    typeArray.push(type);\n    return type;\n}\n\nexport { StreamLanguage, StringStream };\n"],"sourceRoot":""}